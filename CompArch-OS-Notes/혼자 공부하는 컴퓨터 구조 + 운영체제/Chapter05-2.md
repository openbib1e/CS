# Chapter05. CPU 성능 향상 기법

# 05-2. 명령어 병렬 처리 기법

## 명령어 파이프라인

하나의 명령어를 처리하는 과정을 비슷한 시간 간격으로 나누어 보면,

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

이 네 단계로 나눌 수 있다.

|      | t0 | t1 | t2 | t3 | t4 | t5 | t6 |
|------|----|----|----|----|----|----|----|
| 명령어1 | 인출 | 해석 | 실행 | 저장 |    |    |    |
| 명령어2 |    | 인출 | 해석 | 실행 | 저장 |    |    |
| 명령어3 |    |    | 인출 | 해석 | 실행 | 저장 |    |
| 명령어4 |    |    |    | 인출 | 해석 | 실행 | 저장 |

CPU는 같은 단계가 겹치지 않는다면 `각 단계를 동시에 실행`할 수 있다.

t1에서는 명령어 1, 2를 동시에 처리할 수 있고,  
t2에서는 명령어 1, 2, 3을 동시에 처리할 수 있다.

이렇게 명령어를 병렬 수행하는 것을 **명령어 파이프라인**(instruction pipeline)이라고 하고,  
명령어 파이프라인에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝**(instruction pipelining)이라고 한다.

명령어 파이프라인을 사용하지 않고 모든 명령어를 순차적으로만 처리한다면,

|      | t0 | t1 | t2 | t3 | t4 | t5 | t6 | t7 | t8 | t9 | t10 | t11 |
|------|----|----|----|----|----|----|----|----|----|----|-----|-----|
| 명령어1 | 인출 | 해석 | 실행 | 저장 |    |    |    |    |    |    |     |     |
| 명령어2 |    |    |    |    | 인출 | 해석 | 실행 | 저장 |    |    |     |     |
| 명령어3 |    |    |    |    |    |    |    |    | 인출 | 해석 | 실행  | 저장  |

자연스레 명령어 처리 시간이 길어질 수 밖에 없다.

### 파이프라인 위험(pipeline hazard)

명령어 파이프라인이 항상 이상적으로 실행되지는 않는다.  
동시에 명령어를 처리할 수 없어서 성능 향상에 실패하는 경우가 있다.

이러한 상황을 파이프라인 위험이라고 부르고,  
파이프라인 위험에는 크게 **데이터 위험**, **제어 위험**, **구조적 위험**이 있다.

1. 데이터 위험(data hazard)
    - 명령어 간의 의존성에 의해 야기
    - 모든 명령어를 동시에 처리할 수 없고, 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우
    - 명령어1에서 연산 후 레지스터1에 값을 저장하고, 명령어2에서 레지스터1의 값을 사용해야 한다면 명령어2는 명령어1의 데이터에 의존적이기 때문에 동시에 실행하면 정상적으로 작동하지 않을 수 있음
2. 제어 위험(control hazard)
    - 프로그램 카운터의 갑작스런 변화로 야기
    - 프로그램 실행 흐름이 바뀌어 현재 실행 중인 명령어의 다음 주소로 갱신하는 프로그램 카운터 값에 변화가 생기는 경우
    - JUMP, CALL, INTERRUPT ... 
    - 이러한 상황을 방지하기 위해서 CPU가 분기 예측(branch prediction) 기술을 사용
3. 구조적 위험(structural hazard)
    - 서로 다른 명령어가 같은 CPU 부품(ALU, 레지스터)를 사용하려고 할 때 야기
    - 자원 위험(resource hazard)라고 부르기도 함

### 슈퍼스칼라

파이프라이닝은 단일 파이프라인으로도 구현이 가능하지만 오늘날 대부분의 CPU는 여러 개의 파이프라인을 사용한다.

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 **슈퍼스칼라**(supersclar)라고 한다.

슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서, 슈퍼스칼라 CPU라고 한다.

슈퍼스칼라 프로세서는 이론적으로 파이프라인 개수에 비례하여 프로그램 처리 속도가 빠르겠지만,  
그만큼 **파이프라인 위험도**도 증가하기 때문에 반드시 개수에 비례하여 처리 속도가 빠르다고 할 수 없다.

### 비순차적 명령어 처리

비순차적 명령어 처리(Out-of-order execution, OoOE)는 명령어들 간의 '합벅적인 새치기'로 비유할 수 있다.

파이프라인 중단을 막기 위해 명령어를 순착적으로 처리하지 않는 기법.

3번 명령어는 1, 2번의 명령어 실행이 끝난 뒤의 값을 사용해야되는 의존적인 명령어라면,  
1, 2번 명령어가 모두 끝난 뒤에 3번 명령어를 실행해야 된다.

만약 4, 5, 6번 명령어는 의존적이지 않고 계속해서 실행해도 된다면,  
3번 명령어를 4, 5, 6번 명령어 뒤로 옮겨서 명령어 파이프라인이 멈추는 것을 방지할 수 있게 된다.

이처럼 비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지,  
순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지 판단한다.