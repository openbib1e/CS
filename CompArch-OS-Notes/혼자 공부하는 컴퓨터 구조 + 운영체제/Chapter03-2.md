# Chapter03. 명령어

# 03-2. 명령어의 구조

## 연산 코드와 오퍼 랜드

컴퓨터 속 명령어도 사람이 명령할 때처럼 **'무엇을 대상으로, 어떤 작동을 수행하라'**는 구조로 되어있다.

'100과 120을 더하라'라는 문장에서 '더하라'라는 말은 명령의 작동 즉 연산을 의미하고,  
100과 120은 연산에 사용할 데이터가 된다.

'메모리 32번지 안의 값과 메모리 33번지 안의 값을 빼라'라는 문장에서 '빼라'는 연산,  
메모리 32번지 안의 값과 메모리 33번지 안의 값은 연산에 사용할 데이터가 저장된 위치를 말한다.

명령어는 연산 코드와 오퍼랜드로 구성되어 있다.  
**연산 코드**(operation code)는 더하라, 빼라처럼 명령어가 수행할 연산을 의미하고,  
**오퍼랜드**(operand)는 100, 메모리 32번지 값처럼 연산에 사용할 데이터 또는 데이터가 저장된 위치를 의미한다.

### 오퍼랜드

오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미한다고 했다.

실제로 오퍼랜드 값이 담기는 오퍼랜드 필드에는 연산에 사용될 데이터 값이 담기는 상황보다는 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담기는 일이 더 많다.

그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다.

오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개 혹은 두 개, 세 개 등등 여러 개가 있을 수 있다.

오퍼랜드가 하나도 없는 명령어는 0-주소 명령어, 오퍼랜드가 하나인 명령어를 1-주소 명령어 등등 부른다.

### 연산 코드

연산 코드는 명령어가 수행할 연산을 의미한다.

연산 코드의 종류와 생김새는 CPU마다 다르다.  
다양한 연산 코드들이 있지만 CPU가 공통으로 이해하는 대표적인 연산 코드 유형 4가지를 나눌 수 있다.

1. 데이터 전송
    - MOVE : 데이터를 옮겨라
    - STORE : 메모리에 저장하라
    - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
    - PUSH : 스택에 데이터를 저장하라
    - POP : 스택의 최상단 데이터를 가져와라
2. 산술/논리 연산
    - ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하라
    - INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라, 오퍼랜드에 1을 빼라
    - AND / OR / NOT : AND, OR, NOT 연산을 수행하라
    - COMPARE : 두 개의 숫자 또는 TRUE, FALSE 값을 비교하라
3. 제어 흐름 변경
    - JUMP : 특정 주소로 실행 순서를 옮겨라
    - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
    - HALT : 프로그램의 실행을 멈춰라
    - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
4. 입출력 제어
    - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
    - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
    - START IO : 입출력 장치를 시작하라
    - TEST IO : 입출력 장치의 상태를 확인하라

## 주소 지정 방식

앞에서 오퍼랜드 필드에는 메모리나 레지스터 주소를 담는 경우가 많아서 오퍼랜드 필드를 주소 필드라고 부르기도 한다고 했다.

왜 데이터 값을 직접 담는 경우보다 주소를 담는 경우가 더 많을까?

이는 명령어 길이 때문이다.  
1-주소 명령어의 길이가 n비트로 구성되어 있고, 그중 연산 코드 필드가 m비트라면 오퍼랜드 필드는 (n-m)비트 크기를 갖게 된다.

2-주소 명령어, 3-주소 명령어라면 더욱 작은 오퍼랜드 필드를 갖게 된다.  
이 오퍼랜드 필드에 데이터 값을 그대로 넣게 되면 매우 제한적인 데이터 크기만을 표현할 수 있게 된다.

하지만 오퍼랜드 필드에 주소값을 사용한다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커지게 된다.

예를 들어 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트가 되고 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2<sup>6</sup>개가 된다.

이 오퍼랜드 필드 안에 메모리 주소가 담긴다면 해당 주소가 가르키는 곳에 2<sup>16</sup> 크기의 데이터를 표현할 수 있게 된다.

오퍼랜드 필드에 메모리 주소가 아닌 레지스터 이름을 명시할 때도 마찬가지이다. 이 경우에는 표현할 수 있는 정보의 가짓수는 해당 레지스터가 저장할 수 있는 공간만큼 커진다.

연산 코드에 사용할 데이터가 저장된 위치를 **유효 주소**(effective address)라고 한다.

이 유효 주소를 찾는 방법을 **주소 지정 방식**(addressing modes)라고 한다. CPU는 다양한 주소 지정 방식을 사용하지만 가장 대표적인 5가지 방법이 있다.

1. 즉시 주소 지정 방식(immediate addressing mode)
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 가장 간단한 형태의 주소 지정 방식
    - 연산에 사용할 데이터의 크기가 작아질 수 있지만 빠름(메모리나 레지스터로부터 찾는 과정이 없기 때문)
2. 직접 주소 지정 방식(direct addressing mode)
    - 오퍼랜드 필드에 유효 주소 직접적으로 명시
    - 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦
3. 간접 주소 지정 방식(indirect addressing mode)
    - 오퍼랜드 필드에 유효 주소의 주소를 명시
    - 앞선 주소 지정 방식들에 비해 속도가 느림(두 번의 메모리 접근이 필요)
4. 레지스터 주소 지정 방식(register addressing mode)
    - 연산에 사용할 데이터가 저장된 레지스터 명시
    - 메모리(CPU 외부)에 접근하는 속도보다 레지스터(CPU 내부)에 접근하는 것이 빠름
5. 레지스터 간접 주소 지정 방식
    - 연산에 사용할 데이터를 메모리에 저장
    - 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시