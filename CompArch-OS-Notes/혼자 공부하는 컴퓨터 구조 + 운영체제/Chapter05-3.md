# Chapter05. CPU 성능 향상 기법

# 05-3. SISC와 RISC

명령어 파이프라이닝 기법을 효과적으로 사용하려면 명령어가 파이프라이닝하기 쉽게 생겨야 한다.

그렇다면 `파이프라이닝 하기 쉬운 명령어`는 무엇일까!

## 명령어 집합

CPU 마다 규격, 기능 등등이 다르고 명령어의 생김새, 연산, 주소 지정 방식 등 CPU마다 차이가 있다.

**명령어 집합**(instruction set) 또는 **명령어 집합 구조**(Instruction Set Architecture, ISA)는 CPU가 이해할 수 있는 명령어들의 모음을 의미한다.

인텔 제조사에서 만든 CPU가 이해하는 명령어 집합이 따로 있고, 애플에서 만든 명령어 집합은 또 다르게 존재한다.  
CPU는 명령어 집합에 속해있는 명령어만 이해할 수 있다.  
따라서 인텔 컴퓨터에서 만든 실행 파일은 맥북에 옮겨서 특별한 설정없이 바로 실행시킬 수 없다.

ISA가 다르다는 것은 CPU가 이해하는 명령어가 다르다는 것이고, 명령어가 달라지면 어셈블리어도 달라지게 된다.

```c
/* C언어 코드 */
int square(int num) {
    return num * num;
}
```

```assembly
/* x86-64 GCC 14.1 컴파일러 */
square:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     eax, DWORD PTR [rbp-4]
        imul    eax, eax
        pop     rbp
        ret
```

```assembly
/* ARM GCC 14.1.0 컴파일러 */
square:
        push    {r7}
        sub     sp, sp, #12
        add     r7, sp, #0
        str     r0, [r7, #4]
        ldr     r3, [r7, #4]
        mul     r3, r3, r3
        mov     r0, r3
        adds    r7, r7, #12
        mov     sp, r7
        ldr     r7, [sp], #4
        bx      lr
```

이처럼 같은 코드여도 CPU가 이해하고 실행할 수 있는 명령어가 달라서 어셈블리어도 다른 것을 알 수 있다.  
이런 점에서 ISA는 일종의 CPU의 언어인 셈이다.

명령어가 달라지면 그에 대한 나비효과로 많은 것들이 달라진다.  
명령어 해석 방식, 레지스터의 종류와 개수, 메모리 관리 방법, 파이프라이닝의 용이성 등등..

또한 하드웨어 설계에도 큰 영향을 주기 때문에 ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이다.

## CISC

**Complex Instruction Set Computer**의 약자로 그대로 해석하면 `복잡한 명령어 집합을 활용하는 컴퓨터(CPU)`를 의미한다.

인텔에서 사용하는 x86, x86-64는 대표적인 CISC 기반의 ISA이다.

명령어의 형태와 크기가 다양한 가변 길이 명령어를 사용한다.  
**다양하고 강력한 명령어를 활용하고, 상대적으로 적은 수의 명령어로도 프로그램을 실행**할 수 있다.

이러한 장점 덕분에 CISC는 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았다.  
적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다는 점은 메모리 공간을 절약할 수 있다는 장점이 되기 때문이다.

하지만 **명령어 파이프라이닝이 불리하다**는 치명적인 단점이 존재한다.

명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않고,  
명령어 하나를 실행하는 데에 여러 클럭 주기가 필요하다.

그리고 대다수의 복잡한 명령어는 사용 빈도가 낮다.

## RISC

**Reduced Instruction Set Computer**의 약자로 명령어 수를 줄여서 종류가 적고, 짧고 규격화된 명령어를 사용한다.  
CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.

단순하고 적은 수의 고정 길이 명령어를 활용하고 메모리에 접근하는 명령어를 두 개(load, store)로 제한할 만큼 메모리 접근을 단순화, 최소화를 추구한다.

대신 레지스터를 적극적으로 활용하여 CISC보다 레지스터를 이용하는 연산이 많고 범용 레지스터 개수도 더 많다.

ARM은 RISC 기반의 대표적인 ISA이다.  
위에서 같은 소스 코드를 컴파일 했을 때 RISC 기반의 ARM이 더 많은 수의 명령어로 변환되는 것을 볼 수 있다.

## 정리

CISC가 여러 클럭에 걸쳐서 명령어를 수행하고 파이프라이닝하기 어려워도  
제조사에서는 이러한 단점을 해결하기 때문에 CPU 내부적으로 RISC와 비슷하게 동작하도록 설계한다.

| CISC                 | RISC                 |
|----------------------|----------------------|
| 복잡하고 다양한 명령어         | 단순하고 적은 명령어          |
| 가변 길이 명령어            | 고정 길이 명령어            |
| 다양한 주소 지정 방식         | 적은 주소 지정 방식          |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클럭에 걸쳐 명령어 수행     | 1클럭 내외로 명령어 수행       |
| 파이프라이닝하기 어려움         | 파이프라이닝하기 쉬움          |
